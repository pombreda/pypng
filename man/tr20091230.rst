.. $URL$
.. $Rev$

How fast is PyPNG?
==================

This PyPNG Technical Report was written to give a rough idea of how fast
PyPNG is and how aspects of its API and the PNG files affect its speed.

Decoding (reading) PNG files
----------------------------

General Notes
^^^^^^^^^^^^^

Although PyPNG is written in pure Python some of the heavy lifting is
done by Python modules which are usually implemented in C.  The PNG file
format uses the zlib compression algorithm.  When PyPNG is
decompressing the PNG file it will use the ``zlib`` module, therefore
this bit of the process is reasonably fast.

Avoid Repacking
^^^^^^^^^^^^^^^

A general rule of thumb is that if the PNG image data can be passed from
its uncompressed file representation to the format requested in the API
without major modification, then it will be.

For example, if the input PNG is RGBA with 8-bits per channel, and
the :meth:`asDirect` method is used then each row will be copied into a
Python array directly, without handling each pixel.  If however, the PNG
is a 2-bit greyscale image, then PyPNG will need to unpack every byte
into 4 pixels (PNG stores 4 2-bit pixels per byte in this case); this
unpacking is done in Python code and will be very slow.

Filtering
^^^^^^^^^

One of the internal features of the PNG file format is filtering.  Prior
to compression each row can be optionally filtered to try and improve
its compressibility.  When decoding, each row has to be unfiltered after
being decompressed.  In PyPNG the unfiltering is done in Python and is
extremely slow.

In a test, a 4 megapixel RGB test image created with PyPNG was
decoded in about 3.5 seconds.  The same image recoded using Netpbm's
``pnmtopng -paeth`` decodes in about 32 seconds: 9 times slower!  The
difference is that PyPNG does not filter rows when it writes the PNG
file, therefore they need no unfiltering when they are decoded;
``pnmtopng -paeth`` causes each row to be filtered using the Paeth
filter, which requires that each row be unfiltered when decoding.

Paeth is probably something of a worst case when it comes to
filtering, the other filters are not as slow to unfilter.  Typically
a file will use a mixture of filter types.  For example, the same
image was resaved using Apple's Preview tool on OS X (Preview
probably uses a derived version of libpng and probably uses one of
its filter heuristics for choosing filters).  This test image decodes
in about 14 seconds.  About 4 times slower.

If you have any choice in the matter, and you want PyPNG to go quickly,
do not filter your PNG images when saving them.  PyPNG does not filter
its images when saving them, and offers no options to enable filtering.
Enabling filtering can make the output file smaller, but even if PyPNG
were to offer filtering at some later date, it would not be the default
because it would slow down workflows using PyPNG too much.

Channel Extraction
^^^^^^^^^^^^^^^^^^

It's worth mentioning a Python trick to do channel extraction: slicing.
Say we are trying to extract the alpha channel from an RGBA PNG file.
If ``row`` is a single row in boxed row flat pixel format, then
``row[3::4]`` is the alpha channel for this row.

Here's an example: ::

  for row in png.Reader('testRGBA.png').asDirect()[2]:
      row[3::4].tofile(rawfile)

This write out the alpha channel of the file ``testRGBA.png`` to the file
``rawfile`` (the alpha channel is written out as a raw sequence of
bytes).  This code is a little bit naughty, it assumes that each row is
a Python ``array.array`` instance.  Whilst this is not documented, it's
too useful to not rely on, so I'll probably document that rows are
``array.array`` instances.

With a 4 megapixel test image the above code runs in about 4.5 seconds
on my machine.  Using the slice notation for extracting the channel is
essentially free: changing the code to write out all the channels (by
replacing ``row[3::4].tofile`` with ``row.tofile``) makes it run in
about 4.6 seconds.  Even though we do more copying and allocation when
we do the channel extraction, the smaller volume of data we handle makes
up for it.

We can use NetPBM's pngtopam tool to do the same job, but this time
everything happens in compiled C code.  A test using NetPBM
extracts the alpha channel to a file in about 0.44 seconds.  So
PyPNG is about 10 times slower.

Channel Synthesis
^^^^^^^^^^^^^^^^^

If you use the :meth:`asRGBA` method to ask for 4 channels and the
source PNG file has only 3 (RGB) then the alpha channel needs to be
synthesized in Python code.  This takes a small amount of time.
For a 4 megapixel RGB test image, :meth:`asRGB` took about 3.5
seconds, whereas :meth:`asRGBA` took about 4.3 seconds, about 22%
slower.

Interlacing
^^^^^^^^^^^

PNG supports an "interlace" feature; the pixels of an interlaced PNG do
not appear in the file in the same order that they appear in the image
(this feature supports progressive downloading).  PyPNG has to do more
work to reassemble the pixels in the correct order.  In one test, the 4
megapixel RGB test image took about 9.9 seconds to decode when
interlace, about 3.5 when not interlaced.  About 2.8 times slower.
